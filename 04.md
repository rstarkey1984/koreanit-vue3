# 백엔드 데이터 수집 구조 이해

이 문서는 **API 서버가 데이터를 만들어 제공하는 과정**을 이해하기 위한 확장 단계다.

앞선 단계에서 우리는 `/api/news` 엔드포인트를 만들고 JSON 응답을 확인했다.
이제 그 JSON이 **어디서, 어떻게 만들어지는지**를 살펴본다.

> ⚠️ 이 단계는 **Express API 서버 기본 개념을 이해한 이후**에 진행한다.
> Vue에서는 이 내부 구조를 몰라도 `/api/news`만 호출하면 된다.

---

## 1. 왜 서버에서 RSS를 처리할까

브라우저(Vue)에서 RSS를 직접 요청하면 다음 문제가 발생한다.

* CORS 정책으로 요청이 차단될 수 있다
* RSS(XML) 형식은 프론트엔드에서 다루기 불편하다
* 데이터 구조가 서비스에 바로 쓰기 어렵다

그래서 이 프로젝트에서는
**서버가 RSS를 받아 JSON으로 가공**하고,
프론트엔드는 가공된 JSON만 사용한다.

---

## 2. DB 대신 파일을 사용하는 이유

처음부터 데이터베이스를 사용하면 구조가 복잡해진다.

이 단계에서는 DB 대신 **파일 기반 캐시 방식**을 사용한다.

장점

* 설정이 단순하다
* 서버의 역할에 집중할 수 있다
* DB 개념 없이도 데이터 흐름을 이해할 수 있다

이 구조는 나중에 **DB로 자연스럽게 확장 가능**하다.

---

## 3. 폴더 구조

```text
news-api/
├─ package.json
├─ server.js
├─ data/
│  └─ news.json
└─ src/
   ├─ sources.js
   ├─ rss.js
   └─ worker.js
```

폴더 및 파일 생성:
```
mkdir -p data src

touch package.json
touch server.js
touch data/news.json
touch src/sources.js
touch src/rss.js
touch src/worker.js
```

역할

* `sources.js` : RSS 주소 목록
* `rss.js` : RSS 요청 및 XML 파싱, JSON 변환
* `worker.js` : RSS 데이터를 주기적으로 수집해 파일로 저장
* `data/news.json` : 수집된 뉴스 데이터 캐시 파일

---

## 4. RSS 소스 정의

`src/sources.js`

```js
module.exports = {
  kr_it: "https://news.google.com/rss/search?q=IT&hl=ko&gl=KR&ceid=KR:ko",
};
```

이 단계에서는 **소스 1개만 사용**한다.

---

## 5. RSS → JSON 변환 로직

RSS는 XML 형식이므로 파싱이 필요하다.

```bash
npm install xml2js
```

`src/rss.js`

```js
const { parseStringPromise } = require("xml2js");
const crypto = require("crypto");

function makeId(link) {
  return crypto.createHash("sha1").update(link).digest("hex");
}

async function fetchRssToJson(rssUrl, sourceKey) {
  const response = await fetch(rssUrl);
  if (!response.ok) {
    throw new Error(`RSS 요청 실패: ${response.status}`);
  }

  const xml = await response.text();
  const parsed = await parseStringPromise(xml);

  const channel = parsed.rss.channel[0];
  const items = channel.item || [];

  const normalized = items.map((it) => {
    const title = it.title?.[0] || "";
    const link = it.link?.[0] || "";
    const publishedAt = it.pubDate?.[0] || "";
    const publisher = it.source?.[0]?._ || "";

    return {
      id: makeId(link || title),
      title,
      link,
      publisher,
      publishedAt,
    };
  });

  return {
    source: sourceKey,
    updatedAt: new Date().toISOString(),
    count: normalized.length,
    items: normalized,
  };
}

module.exports = { fetchRssToJson };
```

체크 포인트

* 프론트엔드는 XML을 전혀 알 필요가 없다
* `id`는 읽음/즐겨찾기 상태 관리의 기준이 된다

---

## 6. RSS 수집 워커

`src/worker.js`

```js
const fs = require("fs");
const fsp = fs.promises;
const path = require("path");
const { fetchRssToJson } = require("./rss");
const sources = require("./sources");

const DATA_PATH = path.join(__dirname, "..", "data", "news.json");
const TMP_PATH = path.join(__dirname, "..", "data", "news.json.tmp");

const INTERVAL_MS = 3 * 60 * 1000;

async function refreshOnce() {
  const sourceKey = "kr_it";
  const rssUrl = sources[sourceKey];

  const data = await fetchRssToJson(rssUrl, sourceKey);

  // tmp에 먼저 쓰고 rename하는 방식은 원자적 교체(atomic replace)에 가까워서 좋은 패턴
  await fsp.writeFile(TMP_PATH, JSON.stringify(data, null, 2), "utf-8");
  await fsp.rename(TMP_PATH, DATA_PATH);

  console.log(`[worker] saved ${data.count} items`);
}

async function loop() {
  while (true) {
    try {
      await refreshOnce();
    } catch (err) {
      console.error("[worker] refresh failed:", err);
      // 실패해도 워커는 계속 돈다
    }

    await new Promise((r) => setTimeout(r, INTERVAL_MS));
  }
}

loop();
```

포인트

* 서버 실행과 별도로 **백그라운드에서 동작**한다
* 파일은 항상 완성된 상태로 교체된다

---

## 7. API 서버와의 연결 구조

API 서버(`server.js`)는 RSS를 직접 요청하지 않는다.

요청이 들어오면 다음 작업만 수행한다.

1. `data/news.json` 파일 읽기
2. JSON 파싱
3. 그대로 응답

이렇게 역할을 분리하면

* API 서버는 단순해지고
* 데이터 수집 로직은 독립적으로 관리된다

`server.js`
```javascript
const express = require("express");
const fs = require("fs").promises;

const app = express();
const PORT = 3000;
const path = require("path");
const DATA_PATH = path.join(__dirname, "data", "news.json");

// POST 파라미터 파싱 설정
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// 서버 상태 확인용
app.get("/", (req, res) => {
  res.send("API 서버 실행 중");
});

// 뉴스 API (GET): 쿼리스트링 파라미터 확인
// 예) /api/news?limit=2&keyword=it
app.get("/api/news", async (req, res) => {
  const limit = req.query.limit;
  const keyword = req.query.keyword;

  const raw = await fs.readFile(DATA_PATH, "utf-8");
  const data = JSON.parse(raw);
  res.json(data);
});

app.route("/api/dev/:path")
  .get((req, res) => {
    res.json(makeRequestInfo(req));
  })
  .post((req, res) => {
    res.json(makeRequestInfo(req));
  })
  .put((req, res) => {
    res.json(makeRequestInfo(req));
  })
  .delete((req, res) => {
    res.json(makeRequestInfo(req));
  });

function makeRequestInfo(req) {
  return {
    method: req.method,
    url: req.originalUrl,
    params: req.params,
    query: req.query,
    body: req.body,
  };
}

app.listen(PORT, () => {
  console.log(`API 서버 실행: http://localhost:${PORT}`);
});
```

---

## 8. 실행 순서

터미널을 두 개 연다.

### 1) RSS 수집 워커 실행

```bash
node src/worker.js
```

### 2) API 서버 실행

```bash
node server.js
```

브라우저 확인

* `http://localhost:3000/api/news`

또는 VSCode 확장 REST Client 사용
```
### api/news
GET http://localhost:3000/api/news
``` 

---

## 핵심 요약

* 서버는 데이터를 **가공해서 제공하는 역할**을 한다
* DB 없이도 파일 기반 캐시로 충분히 구조를 이해할 수 있다
* Vue는 `/api/news`만 호출하면 된다
* 이 구조는 이후 DB, 인증, 확장으로 자연스럽게 이어진다
