# Node.js에서 MySQL DB 연결 

이 문서는 **DB 생성 → 사용자 생성 → 권한 부여 → 테이블 생성 → Node.js 연결**까지 한 번에 정리한 **강의·실무 표준 흐름**이다.

---

## 0. DB + 사용자 + 권한 + 테이블 생성 (사전 준비)

> 아래 SQL은 **root 계정으로 MySQL 접속 후 순서대로 실행**한다.

### 0-1. 데이터베이스 생성

```sql
CREATE DATABASE node_db
  DEFAULT CHARACTER SET utf8mb4
  COLLATE utf8mb4_general_ci;
```

---

### 0-2. 서비스 전용 사용자 생성

```sql
CREATE USER 'node_user'@'localhost'
IDENTIFIED BY 'node_pass123';
```

* root 계정으로 서비스 연결 ❌
* Node.js 전용 계정 사용 ⭕

---

### 0-3. DB 권한 부여

```sql
GRANT ALL PRIVILEGES
ON node_db.*
TO 'node_user'@'localhost';

FLUSH PRIVILEGES;
```

* 특정 DB에만 권한 부여
* 최소 권한 원칙

---

### 0-4. DB 선택

```sql
USE node_db;
```

---

### 0-5. news_sources 테이블 생성

```sql
CREATE TABLE news_items (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  source_key VARCHAR(50) NOT NULL,
  item_id VARCHAR(200) NOT NULL,     -- RSS에서 만든 고유값(너의 data.items[].id)
  title VARCHAR(500) NOT NULL,
  link TEXT NOT NULL,
  publisher VARCHAR(200) NULL,
  published_at DATETIME NULL,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  UNIQUE KEY uq_source_item (source_key, item_id),
  INDEX idx_source_published (source_key, published_at)
);
```

---

## 1. 필요한 패키지


```bash
cd ~/projects/koreanit/news-api

npm install mysql2
```

* `mysql2/promise` : async / await 사용

---

## 2. 환경변수 설정
> DB 접속 정보 `.env`
```env
DB_HOST=localhost
DB_USER=node_user
DB_PASSWORD=node_pass123
DB_NAME=node_db
DB_PORT=3306
```



---

## 3. 권장 프로젝트 구조

```text
app/db/pool.js
```

* DB 연결은 반드시 **한 파일로 분리**

---

## 4. DB 연결 코드 (db/pool.js)

```js
require("dotenv").config();
const mysql = require("mysql2/promise");

const pool = mysql.createPool({
  host: process.env.DB_HOST,
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  port: process.env.DB_PORT,
  waitForConnections: true,
  connectionLimit: 10,
  queueLimit: 0,
  timezone: "+09:00"
});

module.exports = pool;
```

### 핵심 포인트

* `createPool` 사용 (연결 재사용)
* 매 요청마다 DB 연결 ❌
* 서버 시작 시 한 번 생성 ⭕

---

## 5. 서버 시작 시 DB 연결 테스트
`app/tests/dbtest.js`
```js
const pool = require("../db/pool");

(async () => {
  try {
    const conn = await pool.getConnection();
    console.log("DB 연결 성공");
    conn.release();
  } catch (err) {
    console.error("DB 연결 실패");
    console.error(err.message);
    process.exit(1);
  }
})();
```

* DB 연결 실패 시 서버 실행 중단이 정상

---


## 6. 모델 함수( UPSERT )

`app/models/newsItems.model.js`
```javascript
const pool = require("../db/pool");

/**
 * items를 DB에 저장 (중복은 무시/업데이트)
 * - ON DUPLICATE KEY UPDATE로 동일 (source_key,item_id)면 업데이트 처리
 * - 대량 insert를 한 번에 처리하도록 bulk insert 사용
 */
async function upsertNewsItems(sourceKey, items) {
  if (!items || items.length === 0) return { affectedRows: 0 };

  // publishedAt: "Tue, 13 Jan 2026 02:58:19 GMT" 같은 문자열이면
  // MySQL이 DATETIME으로 변환 가능하지만, 안전하게 Date로 바꿔 넣는 걸 권장
  const values = items.map((it) => [
    sourceKey,
    it.id,
    it.title,
    it.link,
    it.publisher || null,
    it.publishedAt ? new Date(it.publishedAt) : null,
  ]);

  const sql = `
    INSERT INTO news_items
      (source_key, item_id, title, link, publisher, published_at)
    VALUES ?
    ON DUPLICATE KEY UPDATE
      title = VALUES(title),
      link = VALUES(link),
      publisher = VALUES(publisher),
      published_at = VALUES(published_at)
  `;

  // mysql2는 bulk insert에서 VALUES ? + [values] 형태 지원
  const [result] = await pool.query(sql, [values]);
  return { affectedRows: result.affectedRows };
}

module.exports = { upsertNewsItems };
```
### INSERT / UPDATE / DELETE일 때
```javascript
const [result, fields] = await pool.query(...);
```
### result 안에 들어있는 것들:
- result.insertId
- result.affectedRows
- result.changedRows

---

## 7. 워커에 “DB 저장”만 추가
refreshOnce()에 2줄만 추가하면 된다.

`worker.js` 전체코드
```javascript
const fs = require("fs");
const fsp = fs.promises;
const path = require("path");
const { fetchRssToJson } = require("./rss");
const { upsertNewsItems } = require("../models/newsItems.model"); // 추가

const sources = {
  kr_it: "https://news.google.com/rss/search?q=IT&hl=ko&gl=KR&ceid=KR:ko",
};

const DATA_PATH = path.join(__dirname, "..", "data", "news.json");
const TMP_PATH = path.join(__dirname, "..", "data", "news.json.tmp");

const INTERVAL_MS = 3 * 60 * 1000;

async function refreshOnce() {
  const sourceKey = "kr_it";
  const rssUrl = sources["kr_it"];

  const data = await fetchRssToJson(rssUrl, sourceKey);

  // 1) 파일 저장(기존 로직)
  //await fsp.writeFile(TMP_PATH, JSON.stringify(data, null, 2), "utf-8");
  //await fsp.rename(TMP_PATH, DATA_PATH);

  // 2) DB 저장(추가)
  await upsertNewsItems(sourceKey, data.items);

  console.log(`[worker] saved ${data.count} items`);
}

async function loop() {
  while (true) {
    try {
      await refreshOnce();
    } catch (err) {
      console.error("[worker] refresh failed:", err);
    }
    await new Promise((r) => setTimeout(r, INTERVAL_MS));
  }
}

loop();
```

## 8. 모델 함수 ( SELECT 추가 )

`app/models/newsItems.model.js`
```javascript
const pool = require("../db/pool");

/**
 * items를 DB에 저장 (중복은 무시/업데이트)
 * - ON DUPLICATE KEY UPDATE로 동일 (source_key,item_id)면 업데이트 처리
 * - 대량 insert를 한 번에 처리하도록 bulk insert 사용
 */
async function upsertNewsItems(sourceKey, items) {
  if (!items || items.length === 0) return { affectedRows: 0 };

  // publishedAt: "Tue, 13 Jan 2026 02:58:19 GMT" 같은 문자열이면
  // MySQL이 DATETIME으로 변환 가능하지만, 안전하게 Date로 바꿔 넣는 걸 권장
  const values = items.map((it) => [
    sourceKey,
    it.id,
    it.title,
    it.link,
    it.publisher || null,
    it.publishedAt ? new Date(it.publishedAt) : null,
  ]);

  const sql = `
    INSERT INTO news_items
      (source_key, item_id, title, link, publisher, published_at)
    VALUES ?
    ON DUPLICATE KEY UPDATE
      title = VALUES(title),
      link = VALUES(link),
      publisher = VALUES(publisher),
      published_at = VALUES(published_at)
  `;

  // mysql2는 bulk insert에서 VALUES ? + [values] 형태 지원
  const [result] = await pool.query(sql, [values]);
  return { affectedRows: result.affectedRows };
}

async function selectNewsList({ sourceKey, limit = 20 }) {
  const sql = `
    SELECT
      item_id AS id,
      title,
      link,
      publisher,
      published_at AS publishedAt
    FROM news_items
    WHERE source_key = ?
    ORDER BY published_at DESC
    LIMIT ?
  `;

  const [rows] = await pool.execute(sql, [sourceKey, Number(limit)]);
  return rows;
}

module.exports = { upsertNewsItems, selectNewsList };
```

---

## 9. 컨트롤러에서 fs 제거 + SELECT 사용
`app/controllers/news.controller.js`

```javascript
const { ok } = require("../utils/response");
const { selectNewsList } = require("../models/newsItems.model");

async function newsListController(req, res, next) {
  try {
    const sourceKey = req.query.source || "kr_it";
    const limit = req.query.limit || 20;

    res.set("Cache-Control", "public, max-age=60");

    //const raw = await fs.readFile(DATA_PATH, "utf-8");
    //const data = JSON.parse(raw);

    const items = await selectNewsList({ sourceKey, limit });

    return ok(
      res,
      {
        source: sourceKey,
        count: items.length,
        items,
      },
      "뉴스 목록",
      200
    );
  } catch (err) {
    return next(err);
  }
}

function newsPostController(req, res) {
  return ok(res, { message: "NEWS POST" });
}

function newsPutController(req, res) {
  return ok(res, { message: "NEWS PUT" });
}

function newsDeleteController(req, res) {
  return ok(res, { message: "NEWS DELETE" });
}

module.exports = {
  newsListController,
  newsPostController,
  newsPutController,
  newsDeleteController,
};
```