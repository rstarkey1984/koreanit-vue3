# Timeout 처리 · Cache-Control 


## 학습 목표

* 요청이 오래 걸릴 때 서버가 왜 위험해지는지 설명할 수 있다
* Express에서 Timeout 미들웨어를 적용할 수 있다
* 응답 Timeout과 작업 취소(Abort)의 차이를 이해한다
* Cache-Control 헤더의 목적과 기본 사용법을 설명할 수 있다
* 캐시 가능한 응답과 캐시 금지 응답을 구분할 수 있다

---

# 1. Timeout 처리

## 1-1. Timeout이 필요한 상황

요청이 오래 걸리는 대표 케이스

* 외부 API 호출 지연(fetch/axios)
* DB 쿼리 지연
* 파일 I/O 지연
* 코드 버그로 응답이 안 나감(무한 대기)

요청이 계속 살아있으면

* 동시에 유지해야 하는 연결이 늘어난다
* 메모리/CPU 점유가 증가한다
* 정상 요청까지 느려져 장애로 이어진다

핵심 메시지

> 서버는 모든 요청을 끝까지 책임지는 것이 아니라
> 서버 전체가 죽지 않게 관리하는 것이 목표다

---

## 1-2. Express에서 가장 쉬운 Timeout (res.setTimeout)

`app/middlewares/timeout.js`

```js
const { fail } = require("../utils/response");

function timeout(ms = 5000) {
  return (req, res, next) => {
    res.setTimeout(ms, () => {
      // 이미 응답이 나간 경우 중복 응답 방지
      if (res.headersSent) return;

      return fail(res, "요청 처리 시간 초과", 504);
    });

    next();
  };
}

module.exports = timeout;
```

적용 예시

```js
const timeout = require("./middlewares/timeout");

// /api 전체 요청에 5초 제한
app.use("/api", timeout(5000));
```

설명

* `res.setTimeout(ms, cb)` : 응답이 ms 이상 지연되면 cb 실행
* `504` : 시간 초과로 실패 처리한다는 의미로 많이 사용
* `res.headersSent` : 응답이 이미 나간 뒤면 추가 응답 금지

---

# 2. Cache-Control (응답 캐싱)

## 2-1. Cache-Control이 필요한 이유

캐시는

* 서버 부하 감소
* 응답 속도 향상
* 트래픽 절약

을 위해 사용한다.

Rate Limit이 “요청을 막는 것”이라면,
Cache-Control은 “요청을 줄이는 것”이다.

---

## 2-2. Cache-Control 기본 형태 (max-age)

```js
res.set("Cache-Control", "public, max-age=60");
```

의미

* `max-age=60` : 60초 동안 캐시 사용 가능
* `public` : 중간 캐시(프록시/CDN)도 저장 가능

---

## 2-3. 민감한 응답은 캐시 금지 (no-store)

사용자 정보, 토큰 관련 응답 등은 캐시하면 안 된다.

```js
res.set("Cache-Control", "no-store");
```

의미

* 어떤 캐시도 저장 금지(가장 강한 금지 정책)

---

## 2-4. 실무에서 자주 쓰는 정책 예시

* 목록 조회(자주 안 바뀜): `public, max-age=30`
* 설정/카테고리: `public, max-age=300`
* 사용자 개인정보: `no-store`
* 인증/토큰 관련: `no-store`

---

## 핵심 요약

* Timeout은 오래 걸리는 요청이 서버를 잠식하지 못하게 막는다
* `res.setTimeout`으로 간단히 적용할 수 있다
* 응답 종료와 작업 취소는 다르며, 외부 요청은 Abort로 끊을 수 있다
* Cache-Control은 불필요한 요청을 줄여 서버 부하를 낮춘다
* 민감한 응답은 `no-store`로 캐시를 금지해야 한다
