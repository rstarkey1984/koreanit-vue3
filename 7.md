# Express Router 기반 API 서버 구조화 강의안

## 강의 목표

이 강의가 끝나면 학생은 다음을 할 수 있어야 한다.

* Express 서버의 요청 처리 흐름을 단계별로 설명할 수 있다
* 미들웨어 / 라우터 / 컨트롤러의 역할을 구분할 수 있다
* Express Router를 사용해 기능 단위로 API를 분리할 수 있다
* 모든 API 응답을 동일한 JSON 구조로 통일할 수 있다
* 서버 로그가 왜 필요한지 이해하고, 어디에 남겨야 하는지 설명할 수 있다
* async 에러를 한 곳에서 처리하는 구조를 이해한다

---

## 1단계: 서버 코드가 커지면 생기는 문제

초기에는 다음과 같은 코드로 시작한다.

```js
app.get("/api/news", ...);
app.get("/api/users", ...);
app.post("/api/users", ...);
```

### 문제점

* API가 늘어날수록 한 파일이 비대해진다
* 기능별로 코드를 찾기 어렵다
* 팀 작업 시 충돌이 잦아진다

### 결론

* `app`은 서버 전체 설정용
* 기능 단위 API는 `router`로 분리해야 한다

---

## 2단계: Express 요청 처리 흐름 이해

Express는 위에서 아래로 코드를 실행한다.

```
요청
 ↓
app.use()        ← 공통 미들웨어
 ↓
app.use("/api") ← Router 연결
 ↓
router.get()    ← URL + 메서드 매칭
 ↓
controller      ← 실제 로직
 ↓
응답
```

이 흐름을 이해하지 못하면 미들웨어, 에러 핸들러 위치를 항상 헷갈리게 된다.

---

## 3단계: 미들웨어란 무엇인가

### 정의

미들웨어는 모든 요청이 공통으로 거치는 처리 단계다.

### 역할 예시

* 요청 로그 기록
* 인증 확인
* 입력값 검증
* 공통 전처리

### 실습: 요청 로그 미들웨어

```js
app.use((req, res, next) => {
  console.log(`[REQ] ${req.method} ${req.originalUrl}`);
  next();
});
```

### 핵심 포인트

* URL과 상관없이 항상 실행된다
* `next()`를 호출해야 다음 단계로 넘어간다
* 로그는 성공/실패와 상관없이 남겨야 한다

---

## 4단계: 서버 로그의 의미

로그는 단순한 디버깅 출력이 아니다.

### 로그가 필요한 이유

* 어떤 요청이 들어왔는지 추적
* 에러 발생 시 원인 파악
* 서버가 정상 동작 중인지 확인

### 로그를 남길 위치

* 컨트롤러 ❌
* 라우터 ❌
* 공통 미들웨어 ⭕

---

## 5단계: 응답 구조를 먼저 통일해야 하는 이유

### 문제 상황

API마다 응답 구조가 다르면 프론트엔드는 매번 분기 처리를 해야 한다.

### 통일된 응답 규칙

```json
{
  "success": true,
  "code": 200,
  "message": "OK",
  "data": {}
}
```

### 공통 응답 함수

```js
function ok(res, data = null, message = "OK", status = 200) {
  return res.status(status).json({
    success: true,
    code: status,
    message,
    data,
  });
}

function fail(res, message = "Error", status = 500, error = null) {
  return res.status(status).json({
    success: false,
    code: status,
    message,
    error,
  });
}
```

이후부터는 `res.json()`을 직접 사용하지 않는다.

---

## 6단계: 컨트롤러의 역할

### 컨트롤러란

컨트롤러는 요청 하나를 처리하는 실제 로직이다.

### 원칙

* URL을 모른다
* Router 구조를 모른다
* 오직 일만 한다

```js
async function newsListController(req, res) {
  const raw = await fs.readFile(DATA_PATH, "utf-8");
  const data = JSON.parse(raw);
  return ok(res, data, "뉴스 목록");
}
```

---

## 7단계: Router 사용하기

### Router의 역할

* 특정 경로 아래 요청을 전담
* URL + HTTP 메서드 분기만 담당

### 구조 예시

```
/api/news → newsRouter
/api/dev  → devRouter
```

Router 내부에서는 상대 경로만 사용한다.

---

## 8단계: 같은 URL, 다른 메서드 묶기

```js
router
  .route("/:path")
  .get(controller)
  .post(controller)
  .put(controller)
  .delete(controller);
```

* REST 스타일 API에 적합
* 가독성과 유지보수성 향상

---

## 9단계: async 에러를 한 곳으로 모으기

### 문제

* 모든 컨트롤러에 try/catch를 쓰기 어렵다
* 하나라도 빠지면 서버가 종료된다

### 해결: asyncHandler

```js
function asyncHandler(fn) {
  return (req, res, next) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
}
```

#### 기술적 의미 정리

* `fn`은 실제 컨트롤러 함수다
* `asyncHandler(fn)`은 **컨트롤러를 감싼 새로운 함수**를 만들어 Router에 전달한다
* `Promise.resolve()`는 컨트롤러가 async든 아니든 **항상 Promise로 통일**한다
* 컨트롤러 내부에서 에러가 발생하면 Promise가 reject 된다
* `.catch(next)`는 자동으로 `next(err)`를 호출한다

즉, **컨트롤러에서 발생한 모든 에러가 자동으로 Express 에러 처리 흐름으로 전달된다**.

---

## 9-1단계: next 함수의 정체

### next는 무엇인가

`next`는 개발자가 만드는 함수가 아니라 **Express가 요청마다 자동으로 주입해주는 함수**다.

```js
(req, res, next) => { ... }
```

이때 `next`의 역할은 오직 흐름 제어다.

### next의 두 가지 사용법

```js
next();
```

* 현재 미들웨어를 종료하고 다음 미들웨어로 이동

```js
next(err);
```

* 정상 흐름을 중단하고 **에러 처리 미들웨어로 즉시 이동**

### Express 내부 규칙 (중요)

* `next()` → 일반 미들웨어 체인 계속 실행
* `next(err)` → 일반 미들웨어를 건너뛰고 `(err, req, res, next)` 형태의 미들웨어만 실행

### asyncHandler와 next의 관계

```js
Promise.resolve(fn(req, res, next)).catch(next);
```

이 코드는 내부적으로 다음과 같다.

```js
.catch(err => next(err));
```

즉, **컨트롤러에서 발생한 에러를 Express가 인식할 수 있는 형태로 전달**하는 역할을 한다.

---

## 10단계: 전역 에러 핸들러

```js
app.use((err, req, res, next) => {
  return fail(res, "서버 오류", 500, err.message);
});
```

### 핵심 문장

* 컨트롤러는 에러를 처리하지 않는다
* 에러는 위로 던지고 마지막에서 한 번에 처리한다

---

## 11단계: 404 처리

```js
app.use((req, res) => {
  return fail(res, "Not Found", 404);
});
```

* 어떤 Router에도 걸리지 않은 요청의 최종 처리 지점
* 응답 통일의 일부

---

## 정리

* 미들웨어: 공통 처리 + 로그
* Router: 기능 단위 URL 묶음
* Controller: 실제 로직
* 응답: 항상 동일한 구조
* 에러: 마지막에서 한 번

이 구조를 이해하면 Express 이후 어떤 서버 프레임워크를 배워도 쉽게 적응할 수 있다.
